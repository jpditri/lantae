require 'spec_helper'
require_relative '../../lib/ruby/lsp/code_actions'

RSpec.describe Lantae::LSP::CodeActionProvider do
  let(:provider_manager) { instance_double(ProviderManager) }
  let(:tool_manager) { instance_double(ToolManager) }
  let(:code_action_provider) { described_class.new(provider_manager, tool_manager) }

  describe '#get_code_actions' do
    let(:document) do
      {
        uri: 'file:///test.rb',
        language_id: 'ruby',
        content: "def calculate(x, y)\n  result = x + y\n  return result\nend"
      }
    end

    let(:range) do
      {
        'start' => { 'line' => 0, 'character' => 0 },
        'end' => { 'line' => 3, 'character' => 3 }
      }
    end

    let(:context) { { 'diagnostics' => [] } }

    it 'returns refactoring actions' do
      actions = code_action_provider.get_code_actions(document, range, context)
      
      refactor_actions = actions.select { |a| a[:kind].start_with?('refactor') }
      expect(refactor_actions).not_to be_empty
      
      # Should have extract method for multi-line selection
      extract_method = actions.find { |a| a[:title] == 'Extract method' }
      expect(extract_method).not_to be_nil
      expect(extract_method[:command][:command]).to eq('lantae.extractMethod')
    end

    context 'with single line selection' do
      let(:range) do
        {
          'start' => { 'line' => 1, 'character' => 2 },
          'end' => { 'line' => 1, 'character' => 15 }
        }
      end

      it 'provides extract variable action' do
        actions = code_action_provider.get_code_actions(document, range, context)
        
        extract_var = actions.find { |a| a[:title] == 'Extract variable' }
        expect(extract_var).not_to be_nil
        expect(extract_var[:kind]).to eq('refactor.extract')
      end
    end

    context 'with Lantae-generated file' do
      let(:document) do
        {
          uri: 'file:///test.rb',
          language_id: 'ruby',
          content: "# Generated by Lantae AI v1.0.0\ndef calculate(x, y)\n  x + y\nend"
        }
      end

      it 'includes AI-powered actions' do
        actions = code_action_provider.get_code_actions(document, range, context)
        
        ai_actions = actions.select { |a| a[:title].include?('ðŸ¤–') || a[:title].include?('ðŸš€') || a[:title].include?('ðŸ§ª') }
        expect(ai_actions.size).to be >= 3 # At least 3 AI actions expected
        
        # Verify AI action structure
        refactor_action = actions.find { |a| a[:title].include?('Refactor with AI') }
        expect(refactor_action).to include(
          title: match(/Refactor with AI/),
          kind: 'refactor.rewrite',
          command: hash_including(
            command: 'lantae.refactorCode',
            arguments: [document[:uri], range]
          )
        )
      end
    end

    context 'with diagnostics' do
      let(:diagnostic) do
        {
          'range' => range,
          'severity' => 1,
          'code' => 'missing_end',
          'message' => 'Missing end keyword'
        }
      end

      let(:context) { { 'diagnostics' => [diagnostic] } }

      it 'provides quick fixes for diagnostics' do
        allow(code_action_provider).to receive(:get_text_at_range).and_return("def calculate(x, y)\n  x + y")
        
        actions = code_action_provider.get_code_actions(document, range, context)
        
        quick_fixes = actions.select { |a| a[:kind] == 'quickfix' }
        expect(quick_fixes).not_to be_empty
        
        fix = quick_fixes.find { |a| a[:title].include?('Add missing end') }
        expect(fix).not_to be_nil
        expect(fix[:diagnostics]).to include(diagnostic)
      end

      context 'with undefined variable diagnostic' do
        let(:diagnostic) do
          {
            'range' => range,
            'severity' => 1,
            'code' => 'undefined_variable',
            'message' => "Undefined variable 'foo'"
          }
        end

        it 'provides variable definition quick fix' do
          actions = code_action_provider.get_code_actions(document, range, context)
          
          var_fix = actions.find { |a| a[:title].include?("Define variable 'foo'") }
          expect(var_fix).not_to be_nil
          expect(var_fix[:edit][:changes][document[:uri]].first[:newText]).to eq("foo = nil\n")
        end
      end
    end
  end

  describe '#execute_command' do
    let(:uri) { 'file:///test.rb' }
    let(:range) do
      {
        'start' => { 'line' => 0, 'character' => 0 },
        'end' => { 'line' => 3, 'character' => 3 }
      }
    end

    before do
      allow(code_action_provider).to receive(:get_document).and_return({
        uri: uri,
        language_id: 'ruby',
        content: "def calculate(x, y)\n  result = x + y\n  return result\nend"
      })
      allow(code_action_provider).to receive(:get_text_at_range).and_return("def calculate(x, y)\n  result = x + y\n  return result\nend")
    end

    describe 'AI-powered commands' do
      let(:ai_response) { "```ruby\ndef calculate(x, y)\n  x + y\nend\n```" }

      before do
        allow(provider_manager).to receive(:chat).and_return(ai_response)
      end

      it 'executes refactorCode command' do
        result = code_action_provider.execute_command('lantae.refactorCode', [uri, range])
        
        expect(result).to include(:changes)
        expect(result[:changes][uri].first[:newText]).to eq("def calculate(x, y)\n  x + y\nend")
      end

      it 'executes optimizeCode command' do
        result = code_action_provider.execute_command('lantae.optimizeCode', [uri, range])
        
        expect(provider_manager).to have_received(:chat).with(match(/Optimize.*performance/))
        expect(result).to include(:changes)
      end

      it 'executes generateTests command' do
        allow(code_action_provider).to receive(:generate_test_file_path).and_return('file:///test_spec.rb')
        
        result = code_action_provider.execute_command('lantae.generateTests', [uri])
        
        expect(provider_manager).to have_received(:chat).with(match(/Generate comprehensive test cases/))
        expect(result).to include(:documentChanges)
        expect(result[:documentChanges].first[:kind]).to eq('create')
      end

      it 'executes addDocumentation command' do
        result = code_action_provider.execute_command('lantae.addDocumentation', [uri, range])
        
        expect(provider_manager).to have_received(:chat).with(match(/documentation/i))
        expect(result).to include(:changes)
      end

      it 'executes analyzeComplexity command' do
        result = code_action_provider.execute_command('lantae.analyzeComplexity', [uri, range])
        
        expect(provider_manager).to have_received(:chat).with(match(/complexity/i))
        expect(result).to include(:changes)
      end
    end

    describe 'standard refactoring commands' do
      it 'handles extractMethod command' do
        result = code_action_provider.execute_command('lantae.extractMethod', [uri, range])
        # This would typically involve more complex logic
        expect(result).to be_nil # Placeholder implementation
      end

      it 'handles extractVariable command' do
        result = code_action_provider.execute_command('lantae.extractVariable', [uri, range])
        expect(result).to be_nil # Placeholder implementation
      end
    end

    it 'returns nil for unknown commands' do
      result = code_action_provider.execute_command('unknown.command', [])
      expect(result).to be_nil
    end
  end

  describe 'helper methods' do
    let(:document) do
      {
        uri: 'file:///test.rb',
        content: "line 1\nline 2\nline 3\nline 4"
      }
    end

    describe '#get_text_at_range' do
      it 'extracts single line text' do
        range = {
          'start' => { 'line' => 1, 'character' => 0 },
          'end' => { 'line' => 1, 'character' => 6 }
        }
        
        text = code_action_provider.send(:get_text_at_range, document, range)
        expect(text).to eq('line 2')
      end

      it 'extracts multi-line text' do
        range = {
          'start' => { 'line' => 0, 'character' => 5 },
          'end' => { 'line' => 2, 'character' => 4 }
        }
        
        text = code_action_provider.send(:get_text_at_range, document, range)
        expect(text).to eq("1\nline 2\nline")
      end
    end

    describe '#extract_code_from_response' do
      it 'extracts code from markdown blocks' do
        response = "Here's the refactored code:\n```ruby\ndef test\n  puts 'hello'\nend\n```\nThat's better!"
        
        code = code_action_provider.send(:extract_code_from_response, response)
        expect(code).to eq("def test\n  puts 'hello'\nend")
      end

      it 'returns original response if no code block found' do
        response = "Just some plain text"
        
        code = code_action_provider.send(:extract_code_from_response, response)
        expect(code).to eq(response)
      end
    end

    describe '#generate_test_file_path' do
      tests = [
        { input: 'file:///app/models/user.rb', expected: 'file:///app/models/user_spec.rb' },
        { input: 'file:///src/main.py', expected: 'file:///src/test_main.py' },
        { input: 'file:///lib/utils.js', expected: 'file:///lib/utils.test.js' },
        { input: 'file:///pkg/server.go', expected: 'file:///pkg/server_test.go' },
        { input: 'file:///src/app.ts', expected: 'file:///src/app.test.ts' }
      ]

      tests.each do |test|
        it "generates correct test path for #{test[:input]}" do
          path = code_action_provider.send(:generate_test_file_path, test[:input])
          expect(path).to eq(test[:expected])
        end
      end
    end

    describe '#lantae_generated?' do
      it 'detects Lantae-generated files' do
        tests = [
          { content: "# Generated by Lantae AI v1.0.0", expected: true },
          { content: "# _lantae_metadata = {}", expected: true },
          { content: "def regular_code\nend", expected: false }
        ]
        
        tests.each do |test|
          doc = { content: test[:content] }
          result = code_action_provider.send(:lantae_generated?, doc)
          expect(result).to eq(test[:expected])
        end
      end
    end

    describe '#range helpers' do
      it 'detects multi-line ranges' do
        range = { 'start' => { 'line' => 0 }, 'end' => { 'line' => 2 } }
        expect(code_action_provider.send(:range_spans_multiple_lines?, range)).to be true
      end

      it 'detects single-line ranges' do
        range = { 'start' => { 'line' => 1 }, 'end' => { 'line' => 1 } }
        expect(code_action_provider.send(:range_on_single_line?, range)).to be true
      end
    end
  end
end