require 'spec_helper'
require_relative '../../lib/ruby/lsp/client'
require 'timeout'

RSpec.describe Lantae::LSP::Client do
  let(:client) { described_class.new }
  let(:test_file) { '/tmp/test_lsp_client.rb' }
  let(:test_content) { "def hello\n  puts 'world'\nend" }

  before do
    File.write(test_file, test_content)
  end

  after do
    File.delete(test_file) if File.exist?(test_file)
    client.stop if client.instance_variable_get(:@process)
  end

  describe '#initialize' do
    it 'sets default command' do
      expect(client.instance_variable_get(:@server_command)).to include('bin/lantae-lsp')
    end

    it 'accepts custom command' do
      custom_client = Lantae::LSP::Client.new(['custom', 'lsp'])
      expect(custom_client.instance_variable_get(:@server_command)).to eq(['custom', 'lsp'])
    end
  end

  describe '#start' do
    it 'starts the LSP server process', :integration do
      skip "LSP server not available" unless File.exist?(File.join(Dir.pwd, 'bin', 'lantae-lsp'))
      
      expect(client.start).to be true
      expect(client.instance_variable_get(:@server_process)).not_to be_nil
      expect(client.capabilities).to include('textDocumentSync')
    end

    it 'handles server startup failure gracefully' do
      client = Lantae::LSP::Client.new(['nonexistent_command'])
      expect(client.start).to be false
    end
  end

  describe 'LSP operations' do
    before(:each) do
      skip "LSP server not available" unless File.exist?(File.join(Dir.pwd, 'bin', 'lantae-lsp'))
      client.start
    end

    describe '#open_file' do
      it 'opens a file in the LSP server' do
        expect { client.open_file(test_file, test_content, 'ruby') }.not_to raise_error
        
        # Verify file is tracked
        documents = client.instance_variable_get(:@documents)
        expect(documents).to have_key("file://#{test_file}")
        expect(documents["file://#{test_file}"]).to include(
          content: test_content,
          language: 'ruby',
          version: 1
        )
      end
    end

    describe '#get_hover' do
      before do
        client.open_file(test_file, test_content, 'ruby')
      end

      it 'returns hover information' do
        hover = client.get_hover(test_file, 0, 4) # hover over 'hello'
        expect(hover).to be_a(Hash) if hover
      end

      it 'returns nil for invalid position' do
        hover = client.get_hover(test_file, 100, 0)
        expect(hover).to be_nil
      end
    end

    describe '#get_completions' do
      before do
        client.open_file(test_file, test_content, 'ruby')
      end

      it 'returns completion items' do
        completions = client.get_completions(test_file, 1, 2)
        expect(completions).to be_an(Array)
      end
    end

    describe '#get_code_actions' do
      before do
        lantae_content = "# Generated by Lantae AI v1.0.0\n#{test_content}"
        client.open_file(test_file, lantae_content, 'ruby')
      end

      it 'returns code actions for selection' do
        actions = client.get_code_actions(test_file, 1, 0, 3, 3)
        expect(actions).to be_an(Array)
      end

      it 'includes AI actions for Lantae files' do
        actions = client.get_code_actions(test_file, 1, 0, 3, 3)
        ai_actions = actions.select { |a| a['title'].include?('AI') || a['title'].include?('ðŸ¤–') }
        expect(ai_actions).not_to be_empty if actions.any?
      end
    end

    describe '#format_document' do
      before do
        unformatted = "def test\nputs 'hello'\n    end"
        File.write(test_file, unformatted)
        client.open_file(test_file, unformatted, 'ruby')
      end

      it 'returns formatting edits' do
        edits = client.format_document(test_file)
        expect(edits).to be_an(Array)
      end
    end

    describe '#analyze_file' do
      it 'analyzes a file and returns diagnostics' do
        result = client.analyze_file(test_file)
        
        expect(result).to include(
          uri: "file://#{test_file}",
          language: 'ruby',
          diagnostics: be_an(Array)
        )
      end

      it 'detects security issues' do
        insecure_file = '/tmp/insecure.rb'
        insecure_content = "puts \"Password: \#{password}\""
        File.write(insecure_file, insecure_content)
        
        result = client.analyze_file(insecure_file)
        
        # Check if any diagnostics are security-related (looking at code or message)
        security_diagnostics = result[:diagnostics].select { |d| 
          d['code'] == 'security' || d['message']&.match?(/security|password/i)
        }
        expect(security_diagnostics).not_to be_empty if result[:diagnostics].any?
        
        File.delete(insecure_file) if File.exist?(insecure_file)
      end
    end

    describe '#execute_command' do
      before do
        lantae_file = '/tmp/lantae_generated.rb'
        lantae_content = "# Generated by Lantae AI v1.0.0\ndef complex_method\n  x = 1\n  y = 2\n  x + y\nend"
        File.write(lantae_file, lantae_content)
        client.open_file(lantae_file, lantae_content, 'ruby')
      end

      after do
        File.delete('/tmp/lantae_generated.rb') if File.exist?('/tmp/lantae_generated.rb')
      end

      it 'executes refactor command' do
        result = client.execute_command('lantae.refactorCode', [
          "file:///tmp/lantae_generated.rb",
          { start: { line: 1, character: 0 }, end: { line: 5, character: 3 } }
        ])
        
        # Command execution might not return immediate results
        expect { result }.not_to raise_error
      end
    end
  end

  describe '#stop' do
    it 'stops the LSP server process', :integration do
      skip "LSP server not available" unless File.exist?(File.join(Dir.pwd, 'bin', 'lantae-lsp'))
      
      client.start
      process = client.instance_variable_get(:@server_process)
      
      client.stop
      
      # Give process time to terminate
      sleep 0.1
      
      expect(client.instance_variable_get(:@server_process)).to be_nil
    end
  end

  describe 'error handling' do
    before(:each) do
      skip "LSP server not available" unless File.exist?(File.join(Dir.pwd, 'bin', 'lantae-lsp'))
      client.start
    end

    it 'handles timeout gracefully' do
      # Create a fresh client that hasn't started yet
      timeout_client = Lantae::LSP::Client.new
      
      # Mock the wait_for_response method to simulate timeout
      allow(timeout_client).to receive(:wait_for_response).and_return(nil)
      allow(timeout_client).to receive(:send_request).and_return(1)
      
      # Test that it returns nil when timeout occurs
      expect(timeout_client.get_hover(test_file, 0, 0)).to be_nil
    end

    it 'handles invalid file paths' do
      expect { client.open_file('/nonexistent/file.rb', '', 'ruby') }.not_to raise_error
    end

    it 'recovers from server crashes' do
      # Simulate server crash
      process = client.instance_variable_get(:@server_process)
      if process && process.alive?
        Process.kill('TERM', process.pid)
        sleep 0.1
      end
      
      # Should handle gracefully
      expect(client.get_hover(test_file, 0, 0)).to be_nil
    end
  end

  describe 'file URI handling' do
    it 'correctly converts file paths to URIs' do
      uri = client.send(:file_uri, '/path/to/file.rb')
      expect(uri).to eq('file:///path/to/file.rb')
    end

    it 'handles relative paths' do
      uri = client.send(:file_uri, 'relative/path.rb')
      expect(uri).to start_with('file:///')
      expect(uri).to include('relative/path.rb')
    end
  end

  describe 'language detection' do
    tests = [
      { path: 'file.rb', expected: 'ruby' },
      { path: 'file.py', expected: 'python' },
      { path: 'file.js', expected: 'javascript' },
      { path: 'file.ts', expected: 'typescript' },
      { path: 'file.go', expected: 'go' },
      { path: 'file.rs', expected: 'rust' },
      { path: 'file.java', expected: 'java' },
      { path: 'file.lisp', expected: 'lisp' },
      { path: 'file.txt', expected: 'plaintext' }
    ]

    tests.each do |test|
      it "detects #{test[:expected]} for #{test[:path]}" do
        language = client.send(:detect_language, test[:path])
        expect(language).to eq(test[:expected])
      end
    end
  end
end